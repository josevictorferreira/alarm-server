# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mqtt` gem.
# Please instead update this file by running `bin/tapioca gem mqtt`.


Encoding::Converter::LF_NEWLINE_DECORATOR = T.let(T.unsafe(nil), Integer)

# Client class for talking to an MQTT server
#
# source://mqtt//lib/mqtt/version.rb#1
module MQTT; end

# source://mqtt//lib/mqtt/client.rb#7
class MQTT::Client
  # Create a new MQTT Client instance
  #
  # Accepts one of the following:
  # - a URI that uses the MQTT scheme
  # - a hostname and port
  # - a Hash containing attributes to be set on the new instance
  #
  # If no arguments are given then the method will look for a URI
  # in the MQTT_SERVER environment variable.
  #
  # Examples:
  #  client = MQTT::Client.new
  #  client = MQTT::Client.new('mqtt://myserver.example.com')
  #  client = MQTT::Client.new('mqtt://user:pass@myserver.example.com')
  #  client = MQTT::Client.new('myserver.example.com')
  #  client = MQTT::Client.new('myserver.example.com', 18830)
  #  client = MQTT::Client.new(:host => 'myserver.example.com')
  #  client = MQTT::Client.new(:host => 'myserver.example.com', :keep_alive => 30)
  #
  # @raise [ArgumentError]
  # @return [Client] a new instance of Client
  #
  # source://mqtt//lib/mqtt/client.rb#129
  def initialize(*args); end

  # Number of seconds to wait for acknowledgement packets (default is 5 seconds)
  #
  # source://mqtt//lib/mqtt/client.rb#37
  def ack_timeout; end

  # Number of seconds to wait for acknowledgement packets (default is 5 seconds)
  #
  # source://mqtt//lib/mqtt/client.rb#37
  def ack_timeout=(_arg0); end

  # Set a path to a file containing a PEM-format CA certificate and enable peer verification
  #
  # source://mqtt//lib/mqtt/client.rb#206
  def ca_file=(path); end

  # PEM-format client certificate
  #
  # source://mqtt//lib/mqtt/client.rb#189
  def cert=(cert); end

  # Set a path to a file containing a PEM-format client certificate
  #
  # source://mqtt//lib/mqtt/client.rb#184
  def cert_file=(path); end

  # Set the 'Clean Session' flag when connecting? (default is true)
  #
  # source://mqtt//lib/mqtt/client.rb#31
  def clean_session; end

  # Set the 'Clean Session' flag when connecting? (default is true)
  #
  # source://mqtt//lib/mqtt/client.rb#31
  def clean_session=(_arg0); end

  # Clear the incoming message queue.
  #
  # source://mqtt//lib/mqtt/client.rb#446
  def clear_queue; end

  # Client Identifier
  #
  # source://mqtt//lib/mqtt/client.rb#34
  def client_id; end

  # Client Identifier
  #
  # source://mqtt//lib/mqtt/client.rb#34
  def client_id=(_arg0); end

  # Connect to the MQTT server
  # If a block is given, then yield to that block and then disconnect again.
  #
  # source://mqtt//lib/mqtt/client.rb#224
  def connect(clientid = T.unsafe(nil)); end

  # Checks whether the client is connected to the server.
  #
  # @return [Boolean]
  #
  # source://mqtt//lib/mqtt/client.rb#312
  def connected?; end

  # Disconnect from the MQTT server.
  # If you don't want to say goodbye to the server, set send_msg to false.
  #
  # source://mqtt//lib/mqtt/client.rb#294
  def disconnect(send_msg = T.unsafe(nil)); end

  # Return the next message received from the MQTT server.
  # An optional topic can be given to subscribe to.
  #
  # The method either returns the topic and message as an array:
  #   topic,message = client.get
  #
  # Or can be used with a block to keep processing messages:
  #   client.get('test') do |topic,payload|
  #     # Do stuff here
  #   end
  #
  # source://mqtt//lib/mqtt/client.rb#389
  def get(topic = T.unsafe(nil), options = T.unsafe(nil)); end

  # Return the next packet object received from the MQTT server.
  # An optional topic can be given to subscribe to.
  #
  # The method either returns a single packet:
  #   packet = client.get_packet
  #   puts packet.topic
  #
  # Or can be used with a block to keep processing messages:
  #   client.get_packet('test') do |packet|
  #     # Do stuff here
  #     puts packet.topic
  #   end
  #
  # source://mqtt//lib/mqtt/client.rb#416
  def get_packet(topic = T.unsafe(nil)); end

  # Hostname of the remote server
  #
  # source://mqtt//lib/mqtt/client.rb#9
  def host; end

  # Hostname of the remote server
  #
  # source://mqtt//lib/mqtt/client.rb#9
  def host=(_arg0); end

  # Time (in seconds) between pings to remote server (default is 15 seconds)
  #
  # source://mqtt//lib/mqtt/client.rb#28
  def keep_alive; end

  # Time (in seconds) between pings to remote server (default is 15 seconds)
  #
  # source://mqtt//lib/mqtt/client.rb#28
  def keep_alive=(_arg0); end

  # Set to a PEM-format client private key
  #
  # source://mqtt//lib/mqtt/client.rb#200
  def key=(*args); end

  # Set a path to a file containing a PEM-format client private key
  #
  # source://mqtt//lib/mqtt/client.rb#194
  def key_file=(*args); end

  # Last ping response time
  #
  # source://mqtt//lib/mqtt/client.rb#58
  def last_ping_response; end

  # Password to authenticate to the server with
  #
  # source://mqtt//lib/mqtt/client.rb#43
  def password; end

  # Password to authenticate to the server with
  #
  # source://mqtt//lib/mqtt/client.rb#43
  def password=(_arg0); end

  # Port number of the remote server
  #
  # source://mqtt//lib/mqtt/client.rb#12
  def port; end

  # Port number of the remote server
  #
  # source://mqtt//lib/mqtt/client.rb#12
  def port=(_arg0); end

  # Publish a message on a particular topic to the MQTT server.
  #
  # @raise [ArgumentError]
  #
  # source://mqtt//lib/mqtt/client.rb#317
  def publish(topic, payload = T.unsafe(nil), retain = T.unsafe(nil), qos = T.unsafe(nil)); end

  # Returns true if the incoming message queue is empty.
  #
  # @return [Boolean]
  #
  # source://mqtt//lib/mqtt/client.rb#436
  def queue_empty?; end

  # Returns the length of the incoming message queue.
  #
  # source://mqtt//lib/mqtt/client.rb#441
  def queue_length; end

  # @deprecated Please use {#host} instead
  #
  # source://mqtt//lib/mqtt/client.rb#604
  def remote_host; end

  # @deprecated Please use {#host=} instead
  #
  # source://mqtt//lib/mqtt/client.rb#609
  def remote_host=(args); end

  # @deprecated Please use {#port} instead
  #
  # source://mqtt//lib/mqtt/client.rb#614
  def remote_port; end

  # @deprecated Please use {#port=} instead
  #
  # source://mqtt//lib/mqtt/client.rb#619
  def remote_port=(args); end

  # Set the Will for the client
  #
  # The will is a message that will be delivered by the server when the client dies.
  # The Will must be set before establishing a connection to the server
  #
  # source://mqtt//lib/mqtt/client.rb#215
  def set_will(topic, payload, retain = T.unsafe(nil), qos = T.unsafe(nil)); end

  # Set to true to enable SSL/TLS encrypted communication
  #
  # Set to a symbol to use a specific variant of SSL/TLS.
  # Allowed values include:
  #
  # @example Using TLS 1.0
  #   client = Client.new('mqtt.example.com', :ssl => :TLSv1)
  # @see OpenSSL::SSL::SSLContext::METHODS
  #
  # source://mqtt//lib/mqtt/client.rb#25
  def ssl; end

  # Set to true to enable SSL/TLS encrypted communication
  #
  # Set to a symbol to use a specific variant of SSL/TLS.
  # Allowed values include:
  #
  # @example Using TLS 1.0
  #   client = Client.new('mqtt.example.com', :ssl => :TLSv1)
  # @see OpenSSL::SSL::SSLContext::METHODS
  #
  # source://mqtt//lib/mqtt/client.rb#25
  def ssl=(_arg0); end

  # Get the OpenSSL context, that is used if SSL/TLS is enabled
  #
  # source://mqtt//lib/mqtt/client.rb#179
  def ssl_context; end

  # Send a subscribe message for one or more topics on the MQTT server.
  # The topics parameter should be one of the following:
  # * String: subscribe to one topic with QoS 0
  # * Array: subscribe to multiple topics with QoS 0
  # * Hash: subscribe to multiple topics where the key is the topic and the value is the QoS level
  #
  # For example:
  #   client.subscribe( 'a/b' )
  #   client.subscribe( 'a/b', 'c/d' )
  #   client.subscribe( ['a/b',0], ['c/d',1] )
  #   client.subscribe( 'a/b' => 0, 'c/d' => 1 )
  #
  # source://mqtt//lib/mqtt/client.rb#370
  def subscribe(*topics); end

  # Send a unsubscribe message for one or more topics on the MQTT server
  #
  # source://mqtt//lib/mqtt/client.rb#451
  def unsubscribe(*topics); end

  # Username to authenticate to the server with
  #
  # source://mqtt//lib/mqtt/client.rb#40
  def username; end

  # Username to authenticate to the server with
  #
  # source://mqtt//lib/mqtt/client.rb#40
  def username=(_arg0); end

  # The version number of the MQTT protocol to use (default 3.1.1)
  #
  # source://mqtt//lib/mqtt/client.rb#15
  def version; end

  # The version number of the MQTT protocol to use (default 3.1.1)
  #
  # source://mqtt//lib/mqtt/client.rb#15
  def version=(_arg0); end

  # Contents of message that is sent by server when client disconnect
  #
  # source://mqtt//lib/mqtt/client.rb#49
  def will_payload; end

  # Contents of message that is sent by server when client disconnect
  #
  # source://mqtt//lib/mqtt/client.rb#49
  def will_payload=(_arg0); end

  # The QoS level of the will message sent by the server
  #
  # source://mqtt//lib/mqtt/client.rb#52
  def will_qos; end

  # The QoS level of the will message sent by the server
  #
  # source://mqtt//lib/mqtt/client.rb#52
  def will_qos=(_arg0); end

  # If the Will message should be retain by the server after it is sent
  #
  # source://mqtt//lib/mqtt/client.rb#55
  def will_retain; end

  # If the Will message should be retain by the server after it is sent
  #
  # source://mqtt//lib/mqtt/client.rb#55
  def will_retain=(_arg0); end

  # The topic that the Will message is published to
  #
  # source://mqtt//lib/mqtt/client.rb#46
  def will_topic; end

  # The topic that the Will message is published to
  #
  # source://mqtt//lib/mqtt/client.rb#46
  def will_topic=(_arg0); end

  private

  # Support older Ruby
  #
  # source://mqtt//lib/mqtt/client.rb#519
  def current_time; end

  # source://mqtt//lib/mqtt/client.rb#512
  def handle_close; end

  # source://mqtt//lib/mqtt/client.rb#491
  def handle_packet(packet); end

  # source://mqtt//lib/mqtt/client.rb#506
  def handle_timeouts; end

  # source://mqtt//lib/mqtt/client.rb#529
  def keep_alive!; end

  # source://mqtt//lib/mqtt/client.rb#594
  def next_packet_id; end

  # source://mqtt//lib/mqtt/client.rb#575
  def parse_uri(uri); end

  # source://mqtt//lib/mqtt/client.rb#542
  def puback_packet(packet); end

  # Read and check a connection acknowledgement packet
  #
  # source://mqtt//lib/mqtt/client.rb#547
  def receive_connack; end

  # Try to read a packet from the server
  # Also sends keep-alive ping packets.
  #
  # source://mqtt//lib/mqtt/client.rb#465
  def receive_packet; end

  # Send a packet to server
  #
  # @raise [MQTT::NotConnectedException]
  #
  # source://mqtt//lib/mqtt/client.rb#565
  def send_packet(data); end

  # source://mqtt//lib/mqtt/client.rb#485
  def wait_for_puback(id, queue); end

  class << self
    # Create and connect a new MQTT Client
    #
    # Accepts the same arguments as creating a new client.
    # If a block is given, then it will be executed before disconnecting again.
    #
    # Example:
    #  MQTT::Client.connect('myserver.example.com') do |client|
    #    # do stuff here
    #  end
    #
    # source://mqtt//lib/mqtt/client.rb#91
    def connect(*args, &block); end

    # Generate a random client identifier
    # (using the characters 0-9 and a-z)
    #
    # source://mqtt//lib/mqtt/client.rb#99
    def generate_client_id(prefix = T.unsafe(nil), length = T.unsafe(nil)); end
  end
end

# Default attribute values
#
# source://mqtt//lib/mqtt/client.rb#64
MQTT::Client::ATTR_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Timeout between select polls (in seconds)
#
# source://mqtt//lib/mqtt/client.rb#61
MQTT::Client::SELECT_TIMEOUT = T.let(T.unsafe(nil), Float)

# Default port number for unencrypted connections
#
# source://mqtt//lib/mqtt.rb#17
MQTT::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# Default port number for TLS/SSL encrypted connections
#
# source://mqtt//lib/mqtt.rb#20
MQTT::DEFAULT_SSL_PORT = T.let(T.unsafe(nil), Integer)

# Super-class for other MQTT related exceptions
#
# source://mqtt//lib/mqtt.rb#23
class MQTT::Exception < ::Exception; end

# A NotConnectedException will be raised when trying to
# perform a function but no connection has been
# established
#
# source://mqtt//lib/mqtt.rb#34
class MQTT::NotConnectedException < ::MQTT::Exception; end

# An enumeration of the MQTT packet types
#
# source://mqtt//lib/mqtt/packet.rb#1031
MQTT::PACKET_TYPES = T.let(T.unsafe(nil), Array)

# Class representing a MQTT Packet
# Performs binary encoding and decoding of headers
#
# source://mqtt//lib/mqtt/packet.rb#6
class MQTT::Packet
  # Create a new empty packet
  #
  # @return [Packet] a new instance of Packet
  #
  # source://mqtt//lib/mqtt/packet.rb#119
  def initialize(args = T.unsafe(nil)); end

  # The length of the parsed packet body
  #
  # source://mqtt//lib/mqtt/packet.rb#17
  def body_length; end

  # Set the length of the packet body
  #
  # source://mqtt//lib/mqtt/packet.rb#157
  def body_length=(arg); end

  # Get serialisation of packet's body (variable header and payload)
  #
  # source://mqtt//lib/mqtt/packet.rb#169
  def encode_body; end

  # Array of 4 bits in the fixed header
  #
  # source://mqtt//lib/mqtt/packet.rb#14
  def flags; end

  # Array of 4 bits in the fixed header
  #
  # source://mqtt//lib/mqtt/packet.rb#14
  def flags=(_arg0); end

  # Identifier to link related control packets together
  #
  # source://mqtt//lib/mqtt/packet.rb#11
  def id; end

  # Identifier to link related control packets together
  #
  # source://mqtt//lib/mqtt/packet.rb#11
  def id=(_arg0); end

  # Returns a human readable string
  #
  # source://mqtt//lib/mqtt/packet.rb#216
  def inspect; end

  # @deprecated Please use {#id} instead
  #
  # source://mqtt//lib/mqtt/packet.rb#1020
  def message_id; end

  # @deprecated Please use {#id=} instead
  #
  # source://mqtt//lib/mqtt/packet.rb#1025
  def message_id=(args); end

  # Parse the body (variable header and payload) of a packet
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#162
  def parse_body(buffer); end

  # Serialise the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#174
  def to_s; end

  # Get the identifer for this packet type
  #
  # source://mqtt//lib/mqtt/packet.rb#137
  def type_id; end

  # Get the name of the packet type as a string in capitals
  # (like the MQTT specification uses)
  #
  # Example: CONNACK
  #
  # source://mqtt//lib/mqtt/packet.rb#147
  def type_name; end

  # Set packet attributes from a hash of attribute names and values
  #
  # source://mqtt//lib/mqtt/packet.rb#126
  def update_attributes(attr = T.unsafe(nil)); end

  # Check that fixed header flags are valid for types that don't use the flags
  #
  # @private
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#209
  def validate_flags; end

  # The version number of the MQTT protocol to use (default 3.1.0)
  #
  # source://mqtt//lib/mqtt/packet.rb#8
  def version; end

  # Set the protocol version number
  #
  # source://mqtt//lib/mqtt/packet.rb#152
  def version=(arg); end

  protected

  # Encode an array of bits and return them
  #
  # source://mqtt//lib/mqtt/packet.rb#236
  def encode_bits(bits); end

  # Encode an array of bytes and return them
  #
  # source://mqtt//lib/mqtt/packet.rb#231
  def encode_bytes(*bytes); end

  # Encode a 16-bit unsigned integer and return it
  #
  # source://mqtt//lib/mqtt/packet.rb#241
  def encode_short(val); end

  # Encode a UTF-8 string and return it
  # (preceded by the length of the string)
  #
  # source://mqtt//lib/mqtt/packet.rb#248
  def encode_string(str); end

  # Remove 8 bits from the front of buffer
  #
  # source://mqtt//lib/mqtt/packet.rb#268
  def shift_bits(buffer); end

  # Remove one byte from the front of the string
  #
  # source://mqtt//lib/mqtt/packet.rb#263
  def shift_byte(buffer); end

  # Remove n bytes from the front of buffer
  #
  # source://mqtt//lib/mqtt/packet.rb#273
  def shift_data(buffer, bytes); end

  # Remove a 16-bit unsigned integer from the front of buffer
  #
  # source://mqtt//lib/mqtt/packet.rb#257
  def shift_short(buffer); end

  # Remove string from the front of buffer
  #
  # source://mqtt//lib/mqtt/packet.rb#278
  def shift_string(buffer); end

  class << self
    # Create a new packet object from the first byte of a MQTT packet
    #
    # source://mqtt//lib/mqtt/packet.rb#103
    def create_from_header(byte); end

    # Parse buffer into new packet object
    #
    # source://mqtt//lib/mqtt/packet.rb#57
    def parse(buffer); end

    # Parse the header and create a new packet object of the correct type
    # The header is removed from the buffer passed into this function
    #
    # source://mqtt//lib/mqtt/packet.rb#65
    def parse_header(buffer); end

    # Read in a packet from a socket
    #
    # source://mqtt//lib/mqtt/packet.rb#27
    def read(socket); end

    # Read and unpack a single byte from a socket
    #
    # @raise [ProtocolException]
    #
    # source://mqtt//lib/mqtt/packet.rb#221
    def read_byte(socket); end
  end
end

# Default attribute values
#
# source://mqtt//lib/mqtt/packet.rb#20
MQTT::Packet::ATTR_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Class representing an MQTT Connect Acknowledgment Packet
#
# source://mqtt//lib/mqtt/packet.rb#555
class MQTT::Packet::Connack < ::MQTT::Packet
  # Create a new Client Connect packet
  #
  # @return [Connack] a new instance of Connack
  #
  # source://mqtt//lib/mqtt/packet.rb#566
  def initialize(args = T.unsafe(nil)); end

  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#603
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#624
  def inspect; end

  # Parse the body (variable header and payload) of a Connect Acknowledgment packet
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#611
  def parse_body(buffer); end

  # The return code (defaults to 0 for connection accepted)
  #
  # source://mqtt//lib/mqtt/packet.rb#560
  def return_code; end

  # The return code (defaults to 0 for connection accepted)
  #
  # source://mqtt//lib/mqtt/packet.rb#560
  def return_code=(_arg0); end

  # Get a string message corresponding to a return code
  #
  # source://mqtt//lib/mqtt/packet.rb#583
  def return_msg; end

  # Get the Session Present flag
  #
  # source://mqtt//lib/mqtt/packet.rb#573
  def session_present; end

  # Set the Session Present flag
  #
  # source://mqtt//lib/mqtt/packet.rb#578
  def session_present=(arg); end
end

# Default attribute values
#
# source://mqtt//lib/mqtt/packet.rb#563
MQTT::Packet::Connack::ATTR_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Class representing an MQTT Connect Packet
#
# source://mqtt//lib/mqtt/packet.rb#397
class MQTT::Packet::Connect < ::MQTT::Packet
  # Create a new Client Connect packet
  #
  # @return [Connect] a new instance of Connect
  #
  # source://mqtt//lib/mqtt/packet.rb#445
  def initialize(args = T.unsafe(nil)); end

  # Set to false to keep a persistent session with the server
  #
  # source://mqtt//lib/mqtt/packet.rb#408
  def clean_session; end

  # Set to false to keep a persistent session with the server
  #
  # source://mqtt//lib/mqtt/packet.rb#408
  def clean_session=(_arg0); end

  # The client identifier string
  #
  # source://mqtt//lib/mqtt/packet.rb#405
  def client_id; end

  # The client identifier string
  #
  # source://mqtt//lib/mqtt/packet.rb#405
  def client_id=(_arg0); end

  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#460
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#531
  def inspect; end

  # Period the server should keep connection open for between pings
  #
  # source://mqtt//lib/mqtt/packet.rb#411
  def keep_alive; end

  # Period the server should keep connection open for between pings
  #
  # source://mqtt//lib/mqtt/packet.rb#411
  def keep_alive=(_arg0); end

  # Parse the body (variable header and payload) of a Connect packet
  #
  # source://mqtt//lib/mqtt/packet.rb#498
  def parse_body(buffer); end

  # The password for authenticating with the server
  #
  # source://mqtt//lib/mqtt/packet.rb#429
  def password; end

  # The password for authenticating with the server
  #
  # source://mqtt//lib/mqtt/packet.rb#429
  def password=(_arg0); end

  # The version number of the protocol
  #
  # source://mqtt//lib/mqtt/packet.rb#402
  def protocol_level; end

  # The version number of the protocol
  #
  # source://mqtt//lib/mqtt/packet.rb#402
  def protocol_level=(_arg0); end

  # The name of the protocol
  #
  # source://mqtt//lib/mqtt/packet.rb#399
  def protocol_name; end

  # The name of the protocol
  #
  # source://mqtt//lib/mqtt/packet.rb#399
  def protocol_name=(_arg0); end

  # @deprecated Please use {#protocol_level} instead
  #
  # source://mqtt//lib/mqtt/packet.rb#544
  def protocol_version; end

  # @deprecated Please use {#protocol_level=} instead
  #
  # source://mqtt//lib/mqtt/packet.rb#549
  def protocol_version=(args); end

  # The username for authenticating with the server
  #
  # source://mqtt//lib/mqtt/packet.rb#426
  def username; end

  # The username for authenticating with the server
  #
  # source://mqtt//lib/mqtt/packet.rb#426
  def username=(_arg0); end

  # The payload of the Will message
  #
  # source://mqtt//lib/mqtt/packet.rb#423
  def will_payload; end

  # The payload of the Will message
  #
  # source://mqtt//lib/mqtt/packet.rb#423
  def will_payload=(_arg0); end

  # The QoS level to send the Will message as
  #
  # source://mqtt//lib/mqtt/packet.rb#417
  def will_qos; end

  # The QoS level to send the Will message as
  #
  # source://mqtt//lib/mqtt/packet.rb#417
  def will_qos=(_arg0); end

  # Set to true to make the Will message retained
  #
  # source://mqtt//lib/mqtt/packet.rb#420
  def will_retain; end

  # Set to true to make the Will message retained
  #
  # source://mqtt//lib/mqtt/packet.rb#420
  def will_retain=(_arg0); end

  # The topic name to send the Will message to
  #
  # source://mqtt//lib/mqtt/packet.rb#414
  def will_topic; end

  # The topic name to send the Will message to
  #
  # source://mqtt//lib/mqtt/packet.rb#414
  def will_topic=(_arg0); end
end

# Default attribute values
#
# source://mqtt//lib/mqtt/packet.rb#432
MQTT::Packet::Connect::ATTR_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Class representing an MQTT Client Disconnect packet
#
# source://mqtt//lib/mqtt/packet.rb#1001
class MQTT::Packet::Disconnect < ::MQTT::Packet
  # Create a new Client Disconnect packet
  #
  # @return [Disconnect] a new instance of Disconnect
  #
  # source://mqtt//lib/mqtt/packet.rb#1003
  def initialize(args = T.unsafe(nil)); end

  # Check the body
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#1008
  def parse_body(buffer); end
end

# Class representing an MQTT Ping Request packet
#
# source://mqtt//lib/mqtt/packet.rb#969
class MQTT::Packet::Pingreq < ::MQTT::Packet
  # Create a new Ping Request packet
  #
  # @return [Pingreq] a new instance of Pingreq
  #
  # source://mqtt//lib/mqtt/packet.rb#971
  def initialize(args = T.unsafe(nil)); end

  # Check the body
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#976
  def parse_body(buffer); end
end

# Class representing an MQTT Ping Response packet
#
# source://mqtt//lib/mqtt/packet.rb#985
class MQTT::Packet::Pingresp < ::MQTT::Packet
  # Create a new Ping Response packet
  #
  # @return [Pingresp] a new instance of Pingresp
  #
  # source://mqtt//lib/mqtt/packet.rb#987
  def initialize(args = T.unsafe(nil)); end

  # Check the body
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#992
  def parse_body(buffer); end
end

# Class representing an MQTT Publish Acknowledgment packet
#
# source://mqtt//lib/mqtt/packet.rb#630
class MQTT::Packet::Puback < ::MQTT::Packet
  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#632
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#646
  def inspect; end

  # Parse the body (variable header and payload) of a packet
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#637
  def parse_body(buffer); end
end

# Class representing an MQTT Publish Complete packet
#
# source://mqtt//lib/mqtt/packet.rb#713
class MQTT::Packet::Pubcomp < ::MQTT::Packet
  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#715
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#729
  def inspect; end

  # Parse the body (variable header and payload) of a packet
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#720
  def parse_body(buffer); end
end

# Class representing an MQTT Publish message
#
# source://mqtt//lib/mqtt/packet.rb#288
class MQTT::Packet::Publish < ::MQTT::Packet
  # Create a new Publish packet
  #
  # @return [Publish] a new instance of Publish
  #
  # source://mqtt//lib/mqtt/packet.rb#311
  def initialize(args = T.unsafe(nil)); end

  # Duplicate delivery flag
  #
  # source://mqtt//lib/mqtt/packet.rb#315
  def duplicate; end

  # Set the DUP flag (true/false)
  #
  # source://mqtt//lib/mqtt/packet.rb#320
  def duplicate=(arg); end

  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#347
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#374
  def inspect; end

  # Parse the body (variable header and payload) of a Publish packet
  #
  # source://mqtt//lib/mqtt/packet.rb#359
  def parse_body(buffer); end

  # The data to be published
  #
  # source://mqtt//lib/mqtt/packet.rb#302
  def payload; end

  # The data to be published
  #
  # source://mqtt//lib/mqtt/packet.rb#302
  def payload=(_arg0); end

  # Quality of Service level (0, 1, 2)
  #
  # source://mqtt//lib/mqtt/packet.rb#333
  def qos; end

  # Set the Quality of Service level (0/1/2)
  #
  # source://mqtt//lib/mqtt/packet.rb#338
  def qos=(arg); end

  # Retain flag
  #
  # source://mqtt//lib/mqtt/packet.rb#324
  def retain; end

  # Set the retain flag (true/false)
  #
  # source://mqtt//lib/mqtt/packet.rb#329
  def retain=(arg); end

  # The topic name to publish to
  #
  # source://mqtt//lib/mqtt/packet.rb#299
  def topic; end

  # The topic name to publish to
  #
  # source://mqtt//lib/mqtt/packet.rb#299
  def topic=(_arg0); end

  # Check that fixed header flags are valid for this packet type
  #
  # @private
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#368
  def validate_flags; end

  protected

  # source://mqtt//lib/mqtt/packet.rb#386
  def inspect_payload; end
end

# Default attribute values
#
# source://mqtt//lib/mqtt/packet.rb#305
MQTT::Packet::Publish::ATTR_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Class representing an MQTT Publish Received packet
#
# source://mqtt//lib/mqtt/packet.rb#652
class MQTT::Packet::Pubrec < ::MQTT::Packet
  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#654
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#668
  def inspect; end

  # Parse the body (variable header and payload) of a packet
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#659
  def parse_body(buffer); end
end

# Class representing an MQTT Publish Release packet
#
# source://mqtt//lib/mqtt/packet.rb#674
class MQTT::Packet::Pubrel < ::MQTT::Packet
  # Create a new Pubrel packet
  #
  # @return [Pubrel] a new instance of Pubrel
  #
  # source://mqtt//lib/mqtt/packet.rb#681
  def initialize(args = T.unsafe(nil)); end

  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#686
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#707
  def inspect; end

  # Parse the body (variable header and payload) of a packet
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#691
  def parse_body(buffer); end

  # Check that fixed header flags are valid for this packet type
  #
  # @private
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#701
  def validate_flags; end
end

# Default attribute values
#
# source://mqtt//lib/mqtt/packet.rb#676
MQTT::Packet::Pubrel::ATTR_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Class representing an MQTT Subscribe Acknowledgment packet
#
# source://mqtt//lib/mqtt/packet.rb#828
class MQTT::Packet::Suback < ::MQTT::Packet
  # Create a new Subscribe Acknowledgment packet
  #
  # @return [Suback] a new instance of Suback
  #
  # source://mqtt//lib/mqtt/packet.rb#838
  def initialize(args = T.unsafe(nil)); end

  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#855
  def encode_body; end

  # @deprecated Please use {#return_codes} instead
  #
  # source://mqtt//lib/mqtt/packet.rb#879
  def granted_qos; end

  # @deprecated Please use {#return_codes=} instead
  #
  # source://mqtt//lib/mqtt/packet.rb#884
  def granted_qos=(args); end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#872
  def inspect; end

  # Parse the body (variable header and payload) of a packet
  #
  # source://mqtt//lib/mqtt/packet.rb#865
  def parse_body(buffer); end

  # An array of return codes, ordered by the topics that were subscribed to
  #
  # source://mqtt//lib/mqtt/packet.rb#830
  def return_codes; end

  # Set the granted QoS value for each of the topics that were subscribed to
  # Can either be an integer or an array or integers.
  #
  # source://mqtt//lib/mqtt/packet.rb#844
  def return_codes=(value); end
end

# Default attribute values
#
# source://mqtt//lib/mqtt/packet.rb#833
MQTT::Packet::Suback::ATTR_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Class representing an MQTT Client Subscribe packet
#
# source://mqtt//lib/mqtt/packet.rb#735
class MQTT::Packet::Subscribe < ::MQTT::Packet
  # Create a new Subscribe packet
  #
  # @return [Subscribe] a new instance of Subscribe
  #
  # source://mqtt//lib/mqtt/packet.rb#746
  def initialize(args = T.unsafe(nil)); end

  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#789
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#819
  def inspect; end

  # Parse the body (variable header and payload) of a packet
  #
  # source://mqtt//lib/mqtt/packet.rb#800
  def parse_body(buffer); end

  # One or more topic filters to subscribe to
  #
  # source://mqtt//lib/mqtt/packet.rb#737
  def topics; end

  # Set one or more topic filters for the Subscribe packet
  # The topics parameter should be one of the following:
  # * String: subscribe to one topic with QoS 0
  # * Array: subscribe to multiple topics with QoS 0
  # * Hash: subscribe to multiple topics where the key is the topic and the value is the QoS level
  #
  # For example:
  #   packet.topics = 'a/b'
  #   packet.topics = ['a/b', 'c/d']
  #   packet.topics = [['a/b',0], ['c/d',1]]
  #   packet.topics = {'a/b' => 0, 'c/d' => 1}
  #
  # source://mqtt//lib/mqtt/packet.rb#762
  def topics=(value); end

  # Check that fixed header flags are valid for this packet type
  #
  # @private
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#813
  def validate_flags; end
end

# Default attribute values
#
# source://mqtt//lib/mqtt/packet.rb#740
MQTT::Packet::Subscribe::ATTR_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Class representing an MQTT Unsubscribe Acknowledgment packet
#
# source://mqtt//lib/mqtt/packet.rb#942
class MQTT::Packet::Unsuback < ::MQTT::Packet
  # Create a new Unsubscribe Acknowledgment packet
  #
  # @return [Unsuback] a new instance of Unsuback
  #
  # source://mqtt//lib/mqtt/packet.rb#944
  def initialize(args = T.unsafe(nil)); end

  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#949
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#963
  def inspect; end

  # Parse the body (variable header and payload) of a packet
  #
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#954
  def parse_body(buffer); end
end

# Class representing an MQTT Client Unsubscribe packet
#
# source://mqtt//lib/mqtt/packet.rb#890
class MQTT::Packet::Unsubscribe < ::MQTT::Packet
  # Create a new Unsubscribe packet
  #
  # @return [Unsubscribe] a new instance of Unsubscribe
  #
  # source://mqtt//lib/mqtt/packet.rb#901
  def initialize(args = T.unsafe(nil)); end

  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/packet.rb#911
  def encode_body; end

  # Returns a human readable string, summarising the properties of the packet
  #
  # source://mqtt//lib/mqtt/packet.rb#933
  def inspect; end

  # Parse the body (variable header and payload) of a packet
  #
  # source://mqtt//lib/mqtt/packet.rb#919
  def parse_body(buffer); end

  # One or more topic paths to unsubscribe from
  #
  # source://mqtt//lib/mqtt/packet.rb#892
  def topics; end

  # Set one or more topic paths to unsubscribe from
  #
  # source://mqtt//lib/mqtt/packet.rb#906
  def topics=(value); end

  # Check that fixed header flags are valid for this packet type
  #
  # @private
  # @raise [ProtocolException]
  #
  # source://mqtt//lib/mqtt/packet.rb#927
  def validate_flags; end
end

# Default attribute values
#
# source://mqtt//lib/mqtt/packet.rb#895
MQTT::Packet::Unsubscribe::ATTR_DEFAULTS = T.let(T.unsafe(nil), Hash)

# A ProtocolException will be raised if there is a
# problem with data received from a remote host
#
# source://mqtt//lib/mqtt.rb#28
class MQTT::ProtocolException < ::MQTT::Exception; end

# Class for implementing a proxy to filter/mangle MQTT packets.
#
# source://mqtt//lib/mqtt/proxy.rb#3
class MQTT::Proxy
  # Create a new MQTT Proxy instance.
  #
  # Possible argument keys:
  #
  #  :local_host      Address to bind listening socket to.
  #  :local_port      Port to bind listening socket to.
  #  :server_host     Address of upstream server to send packets upstream to.
  #  :server_port     Port of upstream server to send packets upstream to.
  #  :select_timeout  Time in seconds before disconnecting a connection.
  #  :logger          Ruby Logger object to send informational messages to.
  #
  # NOTE: be careful not to connect to yourself!
  #
  # @return [Proxy] a new instance of Proxy
  #
  # source://mqtt//lib/mqtt/proxy.rb#40
  def initialize(args = T.unsafe(nil)); end

  # A filter Proc for packets coming from the client (to the server).
  #
  # source://mqtt//lib/mqtt/proxy.rb#23
  def client_filter=(_arg0); end

  # Address to bind listening socket to
  #
  # source://mqtt//lib/mqtt/proxy.rb#5
  def local_host; end

  # Port to bind listening socket to
  #
  # source://mqtt//lib/mqtt/proxy.rb#8
  def local_port; end

  # Ruby Logger object to send informational messages to
  #
  # source://mqtt//lib/mqtt/proxy.rb#20
  def logger; end

  # Start accepting connections and processing packets.
  #
  # source://mqtt//lib/mqtt/proxy.rb#64
  def run; end

  # Time in seconds before disconnecting an idle connection
  #
  # source://mqtt//lib/mqtt/proxy.rb#17
  def select_timeout; end

  # A filter Proc for packets coming from the server (to the client).
  #
  # source://mqtt//lib/mqtt/proxy.rb#26
  def server_filter=(_arg0); end

  # Address of upstream server to send packets upstream to
  #
  # source://mqtt//lib/mqtt/proxy.rb#11
  def server_host; end

  # Port of upstream server to send packets upstream to.
  #
  # source://mqtt//lib/mqtt/proxy.rb#14
  def server_port; end

  private

  # source://mqtt//lib/mqtt/proxy.rb#84
  def process_packets(client_socket, server_socket); end
end

# MQTT-SN
#
# source://mqtt//lib/mqtt.rb#42
module MQTT::SN; end

# Default port number for unencrypted connections
#
# source://mqtt//lib/mqtt.rb#44
MQTT::SN::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# An enumeration of the MQTT-SN packet types
#
# source://mqtt//lib/mqtt/sn/packet.rb#690
MQTT::SN::PACKET_TYPES = T.let(T.unsafe(nil), Hash)

# Class representing a MQTT::SN Packet
# Performs binary encoding and decoding of headers
#
# source://mqtt//lib/mqtt/sn/packet.rb#7
class MQTT::SN::Packet
  # Create a new empty packet
  #
  # @return [Packet] a new instance of Packet
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#41
  def initialize(args = T.unsafe(nil)); end

  # When true, subscriptions are deleted after disconnect
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#12
  def clean_session; end

  # When true, subscriptions are deleted after disconnect
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#12
  def clean_session=(_arg0); end

  # Duplicate delivery flag
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#8
  def duplicate; end

  # Duplicate delivery flag
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#8
  def duplicate=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#75
  def parse_body(buffer); end

  # Quality of Service level
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#9
  def qos; end

  # Quality of Service level
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#9
  def qos=(_arg0); end

  # Request that gateway prompts for Will
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#11
  def request_will; end

  # Request that gateway prompts for Will
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#11
  def request_will=(_arg0); end

  # Retain flag
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#10
  def retain; end

  # Retain flag
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#10
  def retain=(_arg0); end

  # Serialise the packet
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#60
  def to_s; end

  # One of :normal, :predefined or :short
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#13
  def topic_id_type; end

  # One of :normal, :predefined or :short
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#13
  def topic_id_type=(_arg0); end

  # Get the identifer for this packet type
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#52
  def type_id; end

  # source://mqtt//lib/mqtt/sn/packet.rb#45
  def update_attributes(attr = T.unsafe(nil)); end

  protected

  # Get serialisation of packet's body (variable header and payload)
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#99
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#103
  def encode_flags; end

  # Used where a field can either be a Topic Id or a Topic Name
  # (the Subscribe and Unsubscribe packet types)
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#153
  def encode_topic; end

  # source://mqtt//lib/mqtt/sn/packet.rb#128
  def encode_topic_id; end

  # source://mqtt//lib/mqtt/sn/packet.rb#79
  def parse_flags(flags); end

  # Used where a field can either be a Topic Id or a Topic Name
  # (the Subscribe and Unsubscribe packet types)
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#170
  def parse_topic(topic); end

  # source://mqtt//lib/mqtt/sn/packet.rb#142
  def parse_topic_id(topic_id); end

  class << self
    # Parse buffer into new packet object
    #
    # source://mqtt//lib/mqtt/sn/packet.rb#18
    def parse(buffer); end
  end
end

# source://mqtt//lib/mqtt/sn/packet.rb#182
class MQTT::SN::Packet::Advertise < ::MQTT::SN::Packet
  # Returns the value of attribute duration.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#184
  def duration; end

  # Sets the attribute duration
  #
  # @param value the value to set the attribute duration to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#184
  def duration=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#191
  def encode_body; end

  # Returns the value of attribute gateway_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#183
  def gateway_id; end

  # Sets the attribute gateway_id
  #
  # @param value the value to set the attribute gateway_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#183
  def gateway_id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#195
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#186
MQTT::SN::Packet::Advertise::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#267
class MQTT::SN::Packet::Connack < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#286
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#292
  def parse_body(buffer); end

  # Returns the value of attribute return_code.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#268
  def return_code; end

  # Sets the attribute return_code
  #
  # @param value the value to set the attribute return_code to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#268
  def return_code=(_arg0); end

  # Get a string message corresponding to a return code
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#271
  def return_msg; end
end

# source://mqtt//lib/mqtt/sn/packet.rb#237
class MQTT::SN::Packet::Connect < ::MQTT::SN::Packet
  # Returns the value of attribute client_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#239
  def client_id; end

  # Sets the attribute client_id
  #
  # @param value the value to set the attribute client_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#239
  def client_id=(_arg0); end

  # Get serialisation of packet's body
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#248
  def encode_body; end

  # Returns the value of attribute keep_alive.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#238
  def keep_alive; end

  # Sets the attribute keep_alive
  #
  # @param value the value to set the attribute keep_alive to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#238
  def keep_alive=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#256
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#241
MQTT::SN::Packet::Connect::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#15
MQTT::SN::Packet::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#593
class MQTT::SN::Packet::Disconnect < ::MQTT::SN::Packet
  # Returns the value of attribute duration.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#594
  def duration; end

  # Sets the attribute duration
  #
  # @param value the value to set the attribute duration to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#594
  def duration=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#600
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#608
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#596
MQTT::SN::Packet::Disconnect::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#215
class MQTT::SN::Packet::Gwinfo < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#223
  def encode_body; end

  # Returns the value of attribute gateway_address.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#217
  def gateway_address; end

  # Sets the attribute gateway_address
  #
  # @param value the value to set the attribute gateway_address to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#217
  def gateway_address=(_arg0); end

  # Returns the value of attribute gateway_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#216
  def gateway_id; end

  # Sets the attribute gateway_id
  #
  # @param value the value to set the attribute gateway_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#216
  def gateway_id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#227
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#218
MQTT::SN::Packet::Gwinfo::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#585
class MQTT::SN::Packet::Pingreq < ::MQTT::SN::Packet; end

# source://mqtt//lib/mqtt/sn/packet.rb#589
class MQTT::SN::Packet::Pingresp < ::MQTT::SN::Packet; end

# source://mqtt//lib/mqtt/sn/packet.rb#418
class MQTT::SN::Packet::Puback < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#429
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#420
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#420
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#437
  def parse_body(buffer); end

  # Returns the value of attribute return_code.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#421
  def return_code; end

  # Sets the attribute return_code
  #
  # @param value the value to set the attribute return_code to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#421
  def return_code=(_arg0); end

  # Returns the value of attribute topic_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#419
  def topic_id; end

  # Sets the attribute topic_id
  #
  # @param value the value to set the attribute topic_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#419
  def topic_id=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#423
MQTT::SN::Packet::Puback::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#442
class MQTT::SN::Packet::Pubcomp < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#449
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#443
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#443
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#455
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#445
MQTT::SN::Packet::Pubcomp::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#392
class MQTT::SN::Packet::Publish < ::MQTT::SN::Packet
  # Returns the value of attribute data.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#395
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#395
  def data=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#405
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#394
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#394
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#411
  def parse_body(buffer); end

  # Returns the value of attribute topic_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#393
  def topic_id; end

  # Sets the attribute topic_id
  #
  # @param value the value to set the attribute topic_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#393
  def topic_id=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#397
MQTT::SN::Packet::Publish::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#460
class MQTT::SN::Packet::Pubrec < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#467
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#461
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#461
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#473
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#463
MQTT::SN::Packet::Pubrec::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#478
class MQTT::SN::Packet::Pubrel < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#485
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#479
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#479
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#491
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#481
MQTT::SN::Packet::Pubrel::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#368
class MQTT::SN::Packet::Regack < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#379
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#369
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#369
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#387
  def parse_body(buffer); end

  # Returns the value of attribute return_code.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#371
  def return_code; end

  # Sets the attribute return_code
  #
  # @param value the value to set the attribute return_code to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#371
  def return_code=(_arg0); end

  # Returns the value of attribute topic_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#370
  def topic_id; end

  # Sets the attribute topic_id
  #
  # @param value the value to set the attribute topic_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#370
  def topic_id=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#373
MQTT::SN::Packet::Regack::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#345
class MQTT::SN::Packet::Register < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#355
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#346
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#346
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#363
  def parse_body(buffer); end

  # Returns the value of attribute topic_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#347
  def topic_id; end

  # Sets the attribute topic_id
  #
  # @param value the value to set the attribute topic_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#347
  def topic_id=(_arg0); end

  # Returns the value of attribute topic_name.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#348
  def topic_name; end

  # Sets the attribute topic_name
  #
  # @param value the value to set the attribute topic_name to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#348
  def topic_name=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#350
MQTT::SN::Packet::Register::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#200
class MQTT::SN::Packet::Searchgw < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#206
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#210
  def parse_body(buffer); end

  # Returns the value of attribute radius.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#201
  def radius; end

  # Sets the attribute radius
  #
  # @param value the value to set the attribute radius to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#201
  def radius=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#202
MQTT::SN::Packet::Searchgw::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#519
class MQTT::SN::Packet::Suback < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#531
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#520
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#520
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#537
  def parse_body(buffer); end

  # Returns the value of attribute return_code.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#522
  def return_code; end

  # Sets the attribute return_code
  #
  # @param value the value to set the attribute return_code to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#522
  def return_code=(_arg0); end

  # Returns the value of attribute topic_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#521
  def topic_id; end

  # Sets the attribute topic_id
  #
  # @param value the value to set the attribute topic_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#521
  def topic_id=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#524
MQTT::SN::Packet::Suback::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#496
class MQTT::SN::Packet::Subscribe < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#506
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#497
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#497
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#512
  def parse_body(buffer); end

  # Returns the value of attribute topic_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#498
  def topic_id; end

  # Sets the attribute topic_id
  #
  # @param value the value to set the attribute topic_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#498
  def topic_id=(_arg0); end

  # Returns the value of attribute topic_name.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#499
  def topic_name; end

  # Sets the attribute topic_name
  #
  # @param value the value to set the attribute topic_name to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#499
  def topic_name=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#501
MQTT::SN::Packet::Subscribe::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#567
class MQTT::SN::Packet::Unsuback < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#574
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#568
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#568
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#580
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#570
MQTT::SN::Packet::Unsuback::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#544
class MQTT::SN::Packet::Unsubscribe < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#554
  def encode_body; end

  # Returns the value of attribute id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#545
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#545
  def id=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#560
  def parse_body(buffer); end

  # Returns the value of attribute topic_id.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#546
  def topic_id; end

  # Sets the attribute topic_id
  #
  # @param value the value to set the attribute topic_id to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#546
  def topic_id=(_arg0); end

  # Returns the value of attribute topic_name.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#547
  def topic_name; end

  # Sets the attribute topic_name
  #
  # @param value the value to set the attribute topic_name to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#547
  def topic_name=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#549
MQTT::SN::Packet::Unsubscribe::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#333
class MQTT::SN::Packet::Willmsg < ::MQTT::SN::Packet
  # Returns the value of attribute data.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#334
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#334
  def data=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#336
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#340
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#329
class MQTT::SN::Packet::Willmsgreq < ::MQTT::SN::Packet; end

# source://mqtt//lib/mqtt/sn/packet.rb#670
class MQTT::SN::Packet::Willmsgresp < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#677
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#683
  def parse_body(buffer); end

  # Returns the value of attribute return_code.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#671
  def return_code; end

  # Sets the attribute return_code
  #
  # @param value the value to set the attribute return_code to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#671
  def return_code=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#673
MQTT::SN::Packet::Willmsgresp::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#658
class MQTT::SN::Packet::Willmsgupd < ::MQTT::SN::Packet
  # Returns the value of attribute data.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#659
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#659
  def data=(_arg0); end

  # source://mqtt//lib/mqtt/sn/packet.rb#661
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#665
  def parse_body(buffer); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#301
class MQTT::SN::Packet::Willtopic < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#310
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#318
  def parse_body(buffer); end

  # Returns the value of attribute topic_name.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#302
  def topic_name; end

  # Sets the attribute topic_name
  #
  # @param value the value to set the attribute topic_name to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#302
  def topic_name=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#304
MQTT::SN::Packet::Willtopic::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#297
class MQTT::SN::Packet::Willtopicreq < ::MQTT::SN::Packet; end

# source://mqtt//lib/mqtt/sn/packet.rb#640
class MQTT::SN::Packet::Willtopicresp < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#647
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#653
  def parse_body(buffer); end

  # Returns the value of attribute return_code.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#641
  def return_code; end

  # Sets the attribute return_code
  #
  # @param value the value to set the attribute return_code to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#641
  def return_code=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#643
MQTT::SN::Packet::Willtopicresp::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mqtt//lib/mqtt/sn/packet.rb#613
class MQTT::SN::Packet::Willtopicupd < ::MQTT::SN::Packet
  # source://mqtt//lib/mqtt/sn/packet.rb#622
  def encode_body; end

  # source://mqtt//lib/mqtt/sn/packet.rb#630
  def parse_body(buffer); end

  # Returns the value of attribute topic_name.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#614
  def topic_name; end

  # Sets the attribute topic_name
  #
  # @param value the value to set the attribute topic_name to.
  #
  # source://mqtt//lib/mqtt/sn/packet.rb#614
  def topic_name=(_arg0); end
end

# source://mqtt//lib/mqtt/sn/packet.rb#616
MQTT::SN::Packet::Willtopicupd::DEFAULTS = T.let(T.unsafe(nil), Hash)

# A ProtocolException will be raised if there is a
# problem with data received from a remote host
#
# source://mqtt//lib/mqtt.rb#48
class MQTT::SN::ProtocolException < ::MQTT::Exception; end

# The version number of the MQTT gem
#
# source://mqtt//lib/mqtt/version.rb#3
MQTT::VERSION = T.let(T.unsafe(nil), String)
